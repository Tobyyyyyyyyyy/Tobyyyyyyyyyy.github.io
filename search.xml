<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[颜色透明度]]></title>
    <url>%2F2017%2F08%2F17%2Fwt-alpha%2F</url>
    <content type="text"><![CDATA[简介由于项目实际开发中，设计师习惯报百分比形容颜色透明度，每次都需要手动换算，非常麻烦，故记录一些常用的透明度换算。 常用100% — FF95% — F290% — E685% — D980% — CC75% — BF70% — B365% — A660% — 9955% — 8C50% — 8045% — 7340% — 6635% — 5930% — 4D25% — 4020% — 3315% — 2610% — 1A5% — 0D0% — 00 简单的在线换算工具 百分比 --转换--> var percent = true; $(document).ready(function(){ $("#wt_input").change(function(){ $("#wt_result").val(transformAlpha($(this).val())); }); $("#wt_switch").click(function() { percent = !percent; var text; if (percent) { text = "百分比"; } else { text = "数值"; } $(this).text(text); $("#wt_result").val(transformAlpha($("#wt_input").val())); }); }); function transformAlpha(alpha) { var temp = parseFloat(alpha); if (temp) { if (percent) { return (temp / 100 * 255).toString(16).toUpperCase(); } else{ return temp.toString(16).toUpperCase(); } } return ""; }]]></content>
      <categories>
        <category>Dev</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义Drawable时Attempt to invoke virtual method Drawable$ConstantState.newDrawable() on a null object reference]]></title>
    <url>%2F2017%2F06%2F14%2Fwt-android-drawable-issue%2F</url>
    <content type="text"><![CDATA[简介开发过程中，部分用户(华为 NXT-AL10,华为 MHA AL00等)反馈只要弹框就会崩溃，通过反馈用户的协助，找到日志如下： java.lang.NullPointerExceptionAttempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable()' on a null object reference解析原始1 com.android.internal.policy.BackdropFrameRenderer.onResourcesLoaded(BackdropFrameRenderer.java:113)2 com.android.internal.policy.BackdropFrameRenderer.&lt;init&gt;(BackdropFrameRenderer.java:85)3 com.android.internal.policy.DecorView.onWindowDragResizeStart(DecorView.java:2107)4 android.view.ViewRootImpl.startDragResizing(ViewRootImpl.java:7689)5 android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2068)6 android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1366)7 android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6768)8 android.view.Choreographer$CallbackRecord.run(Choreographer.java:926)9 android.view.Choreographer.doCallbacks(Choreographer.java:735)10 android.view.Choreographer.doFrame(Choreographer.java:667)11 android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:912)12 android.os.Handler.handleCallback(Handler.java:761)13 android.os.Handler.dispatchMessage(Handler.java:98)14 android.os.Looper.loop(Looper.java:156)15 android.app.ActivityThread.main(ActivityThread.java:6531)16 java.lang.reflect.Method.invoke(Native Method)17 com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:941)18 com.android.internal.os.ZygoteInit.main(ZygoteInit.java:831) 解决当在自定义Drawable时，需要注意，如果此Drawable有可能会被当做背景设置为Window的背景，类似于getWindow().setBackgroundDrawable(BlankDrawable),则必须在除了正常的绘制逻辑之外，需要重写Drawable#getConstantState())方法,返回一个不会空的ConstantState对象 解析从上往下首先，根据日志，找到最后的崩溃的位置BackdropFrameRenderer#onResourcesLoaded()： public class BackdropFrameRenderer extends Thread implements Choreographer.FrameCallback &#123; // ... public BackdropFrameRenderer(DecorView decorView, ThreadedRenderer renderer, Rect initialBounds, Drawable resizingBackgroundDrawable, Drawable captionBackgroundDrawable, Drawable userCaptionBackgroundDrawable, int statusBarColor, int navigationBarColor, boolean fullscreen, Rect systemInsets, Rect stableInsets, int resizeMode) &#123; setName("ResizeFrame"); mRenderer = renderer; // 唯一调用的地方 onResourcesLoaded(decorView, resizingBackgroundDrawable, captionBackgroundDrawable, userCaptionBackgroundDrawable, statusBarColor, navigationBarColor); // ... &#125; void onResourcesLoaded(DecorView decorView, Drawable resizingBackgroundDrawable, Drawable captionBackgroundDrawableDrawable, Drawable userCaptionBackgroundDrawable, int statusBarColor, int navigationBarColor) &#123; mDecorView = decorView; // 实际崩溃的位置 mResizingBackgroundDrawable = resizingBackgroundDrawable != null ? resizingBackgroundDrawable.getConstantState().newDrawable() : null; mCaptionBackgroundDrawable = captionBackgroundDrawableDrawable != null ? captionBackgroundDrawableDrawable.getConstantState().newDrawable() : null; mUserCaptionBackgroundDrawable = userCaptionBackgroundDrawable != null ? userCaptionBackgroundDrawable.getConstantState().newDrawable() : null; // ... &#125;&#125; 再往上查DecorView#onWindowDragResizeStart(): @Overridepublic void onWindowDragResizeStart(Rect initialBounds, boolean fullscreen, Rect systemInsets, Rect stableInsets, int resizeMode) &#123; if (mWindow.isDestroyed()) &#123; // If the owner's window is gone, we should not be able to come here anymore. releaseThreadedRenderer(); return; &#125; if (mBackdropFrameRenderer != null) &#123; return; &#125; final ThreadedRenderer renderer = getHardwareRenderer(); if (renderer != null) &#123; loadBackgroundDrawablesIfNeeded(); // BackdropFrameRenderer初始化的地方 mBackdropFrameRenderer = new BackdropFrameRenderer(this, renderer, initialBounds, mResizingBackgroundDrawable, mCaptionBackgroundDrawable, mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState), getCurrentColor(mNavigationColorViewState), fullscreen, systemInsets, stableInsets, resizeMode); // ...&#125; 可以发现传递到BackdropFrameRenderer中的resizingBackgroundDrawable实际是一个DecorView中的局部变量mResizingBackgroundDrawable,此时，查找这个局部变量的来源，包括了两个地方： public void setWindowBackground(Drawable drawable) &#123; if (getBackground() != drawable) &#123; setBackgroundDrawable(drawable); if (drawable != null) &#123; mResizingBackgroundDrawable = enforceNonTranslucentBackground(drawable, mWindow.isTranslucent() || mWindow.isShowingWallpaper()); &#125; else &#123; mResizingBackgroundDrawable = getResizingBackgroundDrawable( getContext(), 0, mWindow.mBackgroundFallbackResource, mWindow.isTranslucent() || mWindow.isShowingWallpaper()); &#125; if (mResizingBackgroundDrawable != null) &#123; mResizingBackgroundDrawable.getPadding(mBackgroundPadding); &#125; else &#123; mBackgroundPadding.setEmpty(); &#125; drawableChanged(); &#125;&#125;private void loadBackgroundDrawablesIfNeeded() &#123; if (mResizingBackgroundDrawable == null) &#123; mResizingBackgroundDrawable = getResizingBackgroundDrawable(getContext(), mWindow.mBackgroundResource, mWindow.mBackgroundFallbackResource, mWindow.isTranslucent() || mWindow.isShowingWallpaper()); if (mResizingBackgroundDrawable == null) &#123; // We shouldn't really get here as the background fallback should be always // available since it is defaulted by the system. Log.w(mLogTag, "Failed to find background drawable for PhoneWindow=" + mWindow); &#125; &#125; if (mCaptionBackgroundDrawable == null) &#123; mCaptionBackgroundDrawable = getContext().getDrawable( R.drawable.decor_caption_title_focused); &#125; if (mResizingBackgroundDrawable != null) &#123; mLastBackgroundDrawableCb = mResizingBackgroundDrawable.getCallback(); mResizingBackgroundDrawable.setCallback(null); &#125;&#125; OK，从最终崩溃向上已经到头了，因为无法确定，到底哪里地方会调用public方法，所以，从触发的地方查查看。 从下而上由于触发地方是项目自定义的一个BottomSheetDialog，初始化代码： public BottomSheetDialog(Context context, int style) &#123; super(context, style); //Override style to ensure not show window's title or background. //TODO: find a way to ensure windowIsFloating attribute is false. requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setBackgroundDrawable(BlankDrawable.getInstance()); WindowManager.LayoutParams layout = getWindow().getAttributes(); layout.width = ViewGroup.LayoutParams.MATCH_PARENT; layout.height = ViewGroup.LayoutParams.MATCH_PARENT; layout.windowAnimations = R.style.DialogNoAnimation; getWindow().setAttributes(layout); init(context, style);&#125; 通过getWindow().setBackgroundDrawable(BlankDrawable.getInstance())往下跟，发现会调用到PhoneWindow的setBackgroundDrawable(drawable)方法： @Overridepublic final void setBackgroundDrawable(Drawable drawable) &#123; if (drawable != mBackgroundDrawable || mBackgroundResource != 0) &#123; mBackgroundResource = 0; mBackgroundDrawable = drawable; if (mDecor != null) &#123; mDecor.setWindowBackground(drawable); &#125; if (mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(drawable != null ? 0 : mBackgroundFallbackResource); &#125; &#125;&#125; 而在这个方法中会把这个drawable设置给DecorView。OK，对上了。 这个时候，查看下之前使用自定义的Drawable代码： /** * A drawable that draw nothing. * @author Rey * */public class BlankDrawable extends Drawable &#123; private static BlankDrawable mInstance; private ColorState mColorState; public static BlankDrawable getInstance()&#123; if(mInstance == null) synchronized (BlankDrawable.class) &#123; if(mInstance == null) mInstance = new BlankDrawable(); &#125; return mInstance; &#125; private BlankDrawable() &#123; mColorState = new ColorState(); &#125; @Override public void draw(Canvas canvas) &#123;&#125; @Override public void setAlpha(int alpha) &#123;&#125; @Override public void setColorFilter(ColorFilter cf) &#123;&#125;&#125; 此方法并没有getConstantState()方法，在起父类Drawable中： /** * Return a &#123;@link ConstantState&#125; instance that holds the shared state of this Drawable. * * @return The ConstantState associated to that Drawable. * @see ConstantState * @see Drawable#mutate() */public ConstantState getConstantState() &#123; return null;&#125; 查看默认为null。 总结一下，就是在某些特殊情况，特殊机型（问我怎么特殊？我怎么知道，问华为去，┑(￣Д ￣)┍），会在某些情况触发了分屏的机制，导致调用到startDragResizing()从而触发了BackdropFrameRenderer中的onResourcesLoaded()而由于自定义的BlankDrawable并没有重写父类getConstantState()方法，导致了NPE 综上，修复代码可简单自定义一个内部类实现ConstantState: /** * A drawable that draw nothing. * @author Rey * */public class BlankDrawable extends Drawable &#123; private static BlankDrawable mInstance; private ColorState mColorState; public static BlankDrawable getInstance()&#123; if(mInstance == null) synchronized (BlankDrawable.class) &#123; if(mInstance == null) mInstance = new BlankDrawable(); &#125; return mInstance; &#125; private BlankDrawable() &#123; mColorState = new ColorState(); &#125; @Override public void draw(Canvas canvas) &#123;&#125; @Override public void setAlpha(int alpha) &#123;&#125; @Override public void setColorFilter(ColorFilter cf) &#123;&#125; @Override public int getOpacity() &#123; return PixelFormat.TRANSPARENT; &#125; // fix bugly: #441332 // 如果自定义Drawable会当做window的背景（getWindow().setBackgroundDrawable(BlankDrawable.getInstance());）， // 需要重写此方法，否则在部分机型（华为 NXT-AL10，华为 MHA AL00等）上，在某些情况，调用到BackdropFrameRenderer#onResourcesLoaded中 // 会导致getConstantState().newDrawable()报NPE。 @Nullable @Override public ConstantState getConstantState() &#123; return mColorState; &#125; final static class ColorState extends ConstantState &#123; @NonNull @Override public Drawable newDrawable() &#123; return BlankDrawable.getInstance(); &#125; @Override public int getChangingConfigurations() &#123; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android重写InputConnection之后，某些设备Crash]]></title>
    <url>%2F2017%2F04%2F24%2Fwt-android-inputconnection%2F</url>
    <content type="text"><![CDATA[简介开发过程中，查看Bugly时，发现在部分机型（酷派，说的就是你），只要点击了自定义的InputConnection的WebView，程序就会直接Crash，Bugly中崩溃日志如下： java.lang.AbstractMethodErrorabstract method not implemented解析原始1 com.play.taptap.richeditor.TapRichEditor$e.performYLPrivateCommand(TapRichEditor.java)2 com.android.internal.view.IInputConnectionWrapper.executeMessage(IInputConnectionWrapper.java:444)3 com.android.internal.view.IInputConnectionWrapper$MyHandler.handleMessage(IInputConnectionWrapper.java:81)4 android.os.Handler.dispatchMessage(Handler.java:99)5 android.os.Looper.loop(Looper.java:153)6 android.app.ActivityThread.main(ActivityThread.java:5305)7 java.lang.reflect.Method.invokeNative(Native Method)8 java.lang.reflect.Method.invoke(Method.java:511)9 com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:848)10 com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)11 dalvik.system.NativeStart.main(Native Method) 故名思议，得知是由于没有实现接口方法performYLPrivateCommand，但是实际上Android标准的InputConnection接口并没有这个方法。经Google，在你要知道的N个Android适配问题中找到了相似问题。 分析既然找到了原因，是由于某些坑爹的厂商（酷派：怪我咯~）在InputConnection接口中新增了一个performYLPrivateCommand方法，那么，对于解决，只要实现这个方法就好。对于Android，只要子类定义了这个方法，那么就算是实现了，加不加Override注解不影响源码的解析。在InputConnection中添加如下方法： public boolean performYLPrivateCommand(String action, Bundle data) &#123; return true;&#125; 经测试，失败。┑(￣Д ￣)┍ 通过Jeb反编译自己代码，并没有找到任何与performYLPrivateCommand相关代码，此时想到，应该是项目构建时，会把未使用的无用代码移除，不会打包进入Apk中，想到的解决方案是，自定义一个接口封装performYLPrivateCommand方法，同时实现InputConnection接口和自定的接口。代码如下： public interface IExtraInputConnection &#123; boolean performYLPrivateCommand(String action, Bundle data);&#125; class TapInputConnection implements InputConnection, IExtraInputConnection &#123; // ... 省略InputConnection相关实现 @Override public boolean performYLPrivateCommand(String action, Bundle data) &#123; return true; &#125;&#125; 打包，测试，还是失败。 反编译， 实现已经存在，只是被混淆了。此时应该防止被混淆，否则会找不到这个方法，在混淆文件中添加如下代码： -keep interface com.iwyatt.IExtraInputConnection &#123; public protected &lt;methods&gt;;&#125; 经测试，成功。 总结 自定义接口封装performYLPrivateCommand 实现InputConnection接口的同时实现自定义的接口 使自定义接口不被混淆 代码public interface IExtraInputConnection &#123; boolean performYLPrivateCommand(String action, Bundle data);&#125; class TapInputConnection implements InputConnection, IExtraInputConnection &#123; // ... 省略InputConnection相关实现 @Override public boolean performYLPrivateCommand(String action, Bundle data) &#123; return true; &#125;&#125; -keep interface com.iwyatt.IExtraInputConnection &#123; public protected &lt;methods&gt;;&#125; 鸣谢 你要知道的N个Android适配问题 Bugly Jeb]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP开发环境搭建]]></title>
    <url>%2F2017%2F04%2F19%2Fwt-php-develop-env%2F</url>
    <content type="text"><![CDATA[开发环境搭建根据自身情况直接装 mac 开发环境，或选用Valet或者Docker搭建 直接装Mac开发环境,注意教程里的php版本比较旧 -&gt; 进阶教程 Valet Docker 使用Valet安装 Homebrew, run ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Composer, run brew install composer Xcode Download from App Store run xcode-select --install run brew install homebrew/php/php70 run brew install --HEAD homebrew/php/php70-memcached Valet, run composer global require laravel/valet, add ~/.composer/vendor/bin to $PATH, run valet install (optional if using local db) mariadb run brew install mariadb 配置 mkdir ~/Sites &amp;&amp; cd ~/Site &amp;&amp; valet park valet domain app or valet domain your-sub-domain.xmxdev.com git clone https://github.com/wt1098078873/Blog_Hexo.git web cd web cp .env.example .env 配置.env composer install --no-scripts 安装PHP依赖库 npm install 安装前端编译组件 运行 (optional if using local db) run brew services start mariadb 打开 http://web.dev 来查看网站 使用Docker Docker LaraDock 参考Valet方式配置&amp;运行 相关资料 Homestead Laravel Tutorial Fractal Packagist Setup a Mac Dev Machine From Scratch]]></content>
      <categories>
        <category>Dev</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Valet</tag>
        <tag>Composer</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson使用时toJson报IllegalArgumentException]]></title>
    <url>%2F2017%2F04%2F19%2Fwt-android-gson-tojson%2F</url>
    <content type="text"><![CDATA[简介使用Gson过程中，在调用其Gson.toJson(Object src)时，一直报java.lang.IllegalArgumentException，异常代码如下： java.lang.IllegalArgumentException: Infinity is not a valid double value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method. at com.google.gson.Gson.checkValidFloatingPoint(Gson.java:324) at com.google.gson.Gson$3.write(Gson.java:316) at com.google.gson.Gson$3.write(Gson.java:302) at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.write(TypeAdapterRuntimeTypeWrapper.java:69) at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.write(ReflectiveTypeAdapterFactory.java:125) at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.write(ReflectiveTypeAdapterFactory.java:243) at com.google.gson.Gson.toJson(Gson.java:669) at com.google.gson.Gson.toJson(Gson.java:648) at com.google.gson.Gson.toJson(Gson.java:603) 查看代码得知，是由于double的值为NaN导致，实际上Json按照规范是不支持特殊的double值（NaN，Infinity，-Infinity）的。 但是坑来了，一般来说，并不会为double初始化为NaN，都是0d的。就猜测是是不是后来被设置的，在项目中，由于使用的网络数据，会调用到Json的解析，手动解析的话，为保证字段的不存在，使用的是JsonObject的optDouble(String name)方法，这个方法代码如下： /*** Returns the value mapped by &#123;@code name&#125; if it exists and is a double or* can be coerced to a double, or &#123;@code NaN&#125; otherwise.*/public double optDouble(String name) &#123; return optDouble(name, Double.NaN);&#125; 好吧，把默认值手动设置0。 FIX. 鸣谢Gson Builder — 特殊类型 Floats &amp; Doubles]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP安装时403问题]]></title>
    <url>%2F2017%2F04%2F14%2Fwt-php-install%2F</url>
    <content type="text"><![CDATA[简介在PHP安装和配置过程中，遇到一个坑，当配置nginx.conf时，项目路径root设置为非Nginx默认路径/usr/local/var/www,比如/Users/wt/Documents/workspace_php/Test时，会一直报403 Forbidden. 解决方案： 检查nginx.conf设置是否正确，并确认对应路径是否有设置的启动文件index.html index.php等 通过 whoami获取当前自己用户，id -g -n $whoami获取当前自己的用户组 设置nginx.conf中#user nobody为 user [用户] [用户组] 鸣谢Mac 下 Nginx、PHP、MySQL 和 PHP-fpm 的安装和配置getgrnam(“user”) failed in /etc/nginx/nginx.conf]]></content>
      <categories>
        <category>Dev</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ViewPager切换页面时调用requestLayout阻塞问题]]></title>
    <url>%2F2017%2F03%2F28%2Fwt-viewpager-requestlayout%2F</url>
    <content type="text"><![CDATA[简介在实际开发过程中，使用到ViewPager+Fragment的方式进行显示布局。由于存在需求缓存已加载的Fragment，故自定义了FragmentAdapter，不destoryItem，仅仅注释了destroyItem方法里的操作，代码NoDestroyItemFragmentAdapter。 至于为什么不设置ViewPager.setOffscreenPageLimit(int limit))方法，是由于如果设置了此方法，会导致所有的页面同时加载，增加了缓存布局数量。 BUG描述此时，导致了一个问题：当有非当前展示的页面需要刷新时，调用的requestLayout()无法执行到onLayout()方法。对应项目中的现象就是：调用notifyDataChanged()无法刷新列表。 解决在Fragment的setMenuVisibility中调用一次requestLayout()。保证当前View的PFLAG_FORCE_LAYOUT被消费掉。 @Overridepublic void setMenuVisibility(boolean menuVisible) &#123; super.setMenuVisibility(menuVisible); //解决当非当前页面刷新了此页面时,requestLayout无限阻塞问题 if (menuVisible &amp;&amp; null != getView())&#123; getView().postDelayed(new Runnable() &#123; @Override public void run() &#123; if (null == getView()) &#123; return; &#125; getView().requestLayout(); &#125; &#125;, 200); &#125;&#125; 分析查看RecyclerView源码，查看RecyclerViewDataObserver的onChanged方法 @Overridepublic void onChanged() &#123; assertNotInLayoutOrScroll(null); if (mAdapter.hasStableIds()) &#123; // TODO Determine what actually changed. // This is more important to implement now since this callback will disable all // animations because we cannot rely on positions. mState.mStructureChanged = true; setDataSetChangedAfterLayout(); &#125; else &#123; mState.mStructureChanged = true; setDataSetChangedAfterLayout(); &#125; if (!mAdapterHelper.hasPendingUpdates()) &#123; requestLayout(); &#125;&#125; 继续查看requestLayout()和onLayout()方法; @Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;@Overridepublic void requestLayout() &#123; if (mEatRequestLayout == 0 &amp;&amp; !mLayoutFrozen) &#123; super.requestLayout(); &#125; else &#123; mLayoutRequestEaten = true; &#125;&#125; 其中dispatchLayout()即为RecyclerView页面布局。 查看View.requestLayout()方法 @CallSuperpublic void requestLayout() &#123; if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123; // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123; if (!viewRoot.requestLayoutDuringLayout(this)) &#123; return; &#125; &#125; mAttachInfo.mViewRequestingLayout = this; &#125; mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123; mAttachInfo.mViewRequestingLayout = null; &#125;&#125; 当断点到mParent.isLayoutRequested()时发现，此时其mParent的mPrivateFlags存在标志位PFLAG_FORCE_LAYOUT即mParent.isLayoutRequested()返回的是true 而对于标志位PFLAG_FORCE_LAYOUT是在forceLayout()和requestLayout()时设置,layout结束时清空： public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; // onLayout &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; 此时，想到会不会是因为布局的父类只被requestLayout()而没有执行layout方法。对应的父类就是ViewPager，此时查看ViewPager的onLayout方法： @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; final int count = getChildCount(); int width = r - l; int height = b - t; int paddingLeft = getPaddingLeft(); int paddingTop = getPaddingTop(); int paddingRight = getPaddingRight(); int paddingBottom = getPaddingBottom(); final int scrollX = getScrollX(); int decorCount = 0; // First pass - decor views. We need to do this in two passes so that // we have the proper offsets for non-decor views later. //省略第一步的代码，此段代码只对应layout DecorView //如下代码计算子布局 final int childWidth = width - paddingLeft - paddingRight; // Page views. Do this once we have the right padding offsets from above. for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); ItemInfo ii; // 查看是否为DectorView并且当前子布局在缓存的列表中存在。坑就在这里 if (!lp.isDecor &amp;&amp; (ii = infoForChild(child)) != null) &#123; int loff = (int) (childWidth * ii.offset); int childLeft = paddingLeft + loff; int childTop = paddingTop; if (lp.needsMeasure) &#123; // This was added during layout and needs measurement. // Do it now that we know what we're working with. lp.needsMeasure = false; final int widthSpec = MeasureSpec.makeMeasureSpec( (int) (childWidth * lp.widthFactor), MeasureSpec.EXACTLY); final int heightSpec = MeasureSpec.makeMeasureSpec( (int) (height - paddingTop - paddingBottom), MeasureSpec.EXACTLY); child.measure(widthSpec, heightSpec); &#125; if (DEBUG) Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth() + "x" + child.getMeasuredHeight()); child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight()); &#125; &#125; &#125; mTopPageBounds = paddingTop; mBottomPageBounds = height - paddingBottom; mDecorChildCount = decorCount; if (mFirstLayout) &#123; scrollToItem(mCurItem, false, 0, false); &#125; mFirstLayout = false; &#125; 在上面的判断中会判断是否存在ViewPager缓存的列表中，而这个列表维护是在起当有元素新增时添加，当元素移除时删除。坑就在这里。 在当前项目，由于没有设置默认绘制的数量，使用了其默认数量即当前+1+1（一前一后），此时如果当切换的Item超过了这个数量，布局的里面的列表item就不会包括切换前的那个布局，就导致切换前的那个布局无法layout()。从而导致了后面的一系列问题（子View的requestLayout()无法响应）。 总结 当自定义了如下adapter之后，可通过再次调用requestLayout()来解决 可通过ViewPager的ViewPager.setOffscreenPageLimit(int limit)进行控制 代码区NoDestroyItemFragmentAdapter/* * Copyright (C) 2011 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */import android.os.Bundle;import android.os.Parcelable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v4.view.PagerAdapter;import android.util.Log;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;public abstract class NoDestroyItemFragmentAdapter extends PagerAdapter &#123; private static final String TAG = "taptapada"; private static final boolean DEBUG = false; private final FragmentManager mFragmentManager; private FragmentTransaction mCurTransaction = null; private ArrayList&lt;Fragment.SavedState&gt; mSavedState = new ArrayList&lt;Fragment.SavedState&gt;(); private ArrayList&lt;Fragment&gt; mFragments = new ArrayList&lt;Fragment&gt;(); private Fragment mCurrentPrimaryItem = null; public NoDestroyItemFragmentAdapter(FragmentManager fm) &#123; mFragmentManager = fm; &#125; /** * Return the Fragment associated with a specified position. */ public abstract Fragment getItem(int position); @Override public void startUpdate(ViewGroup container) &#123; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; // If we already have this item instantiated, there is nothing // to do. This can happen when we are restoring the entire pager // from its saved state, where the fragment manager has already // taken care of restoring the fragments we previously had instantiated. if (mFragments.size() &gt; position) &#123; Fragment f = mFragments.get(position); if (f != null) &#123; return f; &#125; &#125; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; Fragment fragment = getItem(position); if (mSavedState.size() &gt; position) &#123; Fragment.SavedState fss = mSavedState.get(position); if (fss != null) &#123; fragment.setInitialSavedState(fss); &#125; &#125; while (mFragments.size() &lt;= position) &#123; mFragments.add(null); &#125; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); mFragments.set(position, fragment); mCurTransaction.add(container.getId(), fragment); return fragment; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123;// Fragment fragment = (Fragment) object;//// if (mCurTransaction == null) &#123;// mCurTransaction = mFragmentManager.beginTransaction();// &#125;// if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object// + " v=" + ((Fragment)object).getView());// while (mSavedState.size() &lt;= position) &#123;// mSavedState.add(null);// &#125;// mSavedState.set(position, fragment.isAdded()// ? mFragmentManager.saveFragmentInstanceState(fragment) : null);// mFragments.set(position, null);//// mCurTransaction.remove(fragment); &#125; @Override public void setPrimaryItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment)object; if (fragment != mCurrentPrimaryItem) &#123; if (mCurrentPrimaryItem != null) &#123; mCurrentPrimaryItem.setMenuVisibility(false); mCurrentPrimaryItem.setUserVisibleHint(false); &#125; if (fragment != null) &#123; fragment.setMenuVisibility(true); fragment.setUserVisibleHint(true); &#125; mCurrentPrimaryItem = fragment; &#125; &#125; @Override public void finishUpdate(ViewGroup container) &#123;// if (mCurTransaction == null) &#123;// mCurTransaction = mFragmentManager.beginTransaction();// &#125; if (mCurTransaction != null) &#123; mCurTransaction.commitAllowingStateLoss(); mCurTransaction = null; mFragmentManager.executePendingTransactions(); &#125; &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return ((Fragment)object).getView() == view; &#125; @Override public Parcelable saveState() &#123; Bundle state = null; if (mSavedState.size() &gt; 0) &#123; state = new Bundle(); Fragment.SavedState[] fss = new Fragment.SavedState[mSavedState.size()]; mSavedState.toArray(fss); state.putParcelableArray("states", fss); &#125; for (int i=0; i&lt;mFragments.size(); i++) &#123; Fragment f = mFragments.get(i); if (f != null &amp;&amp; f.isAdded()) &#123; if (state == null) &#123; state = new Bundle(); &#125; String key = "f" + i; mFragmentManager.putFragment(state, key, f); &#125; &#125; return state; &#125; @Override public void restoreState(Parcelable state, ClassLoader loader) &#123; if (state != null) &#123; Bundle bundle = (Bundle)state; bundle.setClassLoader(loader); Parcelable[] fss = bundle.getParcelableArray("states"); mSavedState.clear(); mFragments.clear(); if (fss != null) &#123; for (int i=0; i&lt;fss.length; i++) &#123; mSavedState.add((Fragment.SavedState)fss[i]); &#125; &#125; Iterable&lt;String&gt; keys = bundle.keySet(); for (String key: keys) &#123; if (key.startsWith("f")) &#123; int index = Integer.parseInt(key.substring(1)); Fragment f = mFragmentManager.getFragment(bundle, key); if (f != null) &#123; while (mFragments.size() &lt;= index) &#123; mFragments.add(null); &#125; f.setMenuVisibility(false); mFragments.set(index, f); &#125; else &#123; Log.w(TAG, "Bad fragment at key " + key); &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
        <tag>View.requestLayout()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于AndroidStudio2.3 SDKManagerGUI隐藏问题]]></title>
    <url>%2F2017%2F03%2F17%2Fwt-android-studio-show-sdkmanager%2F</url>
    <content type="text"><![CDATA[简介更新了AndroidStudio2.3正式版之后，之前可以在Preferences - Android SDK中的 Launch Standalone SDK Manager 按钮被隐藏了。 方案Google之后，找到这个，发现可以通过命令行调起GUI。 命令如下: sdkpath/tools/android sdk 如果在自己的环境变量中已把SDK的tools也添加到了Path中，则只需调用: android sdk 当然也可以全部使用命令行进行操作，官方链接，具体步骤如下: 首先需要把sdkpath/tools/bin添加到环境变量的Path中 调用 sdkmanager –help 即可查看所有的命令 更新于： 2017-03-22 11:25:33 以上仅针对SDK版本低于25.3.0，在之上，android命令已被弃用，再调用这个，会报: The android command is no longer available.For manual SDK and AVD management, please use Android Studio.For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager So…只能使用命令行或者通过AndroidStudio的更新提示框更新。┑(￣Д ￣)┍]]></content>
      <categories>
        <category>IDE</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>SDKManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drawable基础用法 - 水圈循环]]></title>
    <url>%2F2017%2F01%2F18%2Fwt-circle-animation-drawable%2F</url>
    <content type="text"><![CDATA[简介受这篇博客#Android# 轮子杂评启发，重写了之前写的这个空间实现这个效果。Github链接 在此。 用法step1mAnimationDrawable = new CircleAnimationDrawable(200);img.setImageDrawable(mAnimationDrawable); step2@Overrideprotected void onResume() &#123; super.onResume(); if (null != mAnimationDrawable) &#123; mAnimationDrawable.start(); &#125;&#125; step3@Overrideprotected void onPause() &#123; super.onPause(); if (null != mAnimationDrawable) &#123; mAnimationDrawable.stop(); &#125;&#125; 实现的效果 View源码import android.graphics.Canvas;import android.graphics.ColorFilter;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.Rect;import android.graphics.drawable.Animatable;import android.graphics.drawable.Drawable;import android.support.annotation.NonNull;import android.view.animation.AnimationUtils;/** * Drawable基础用法 - 水圈循环 * &lt;p&gt; * Created by wt on 17/1/17. */public class CircleAnimationDrawable extends Drawable implements Animatable, Runnable &#123; private static final int DEFAULT_ANIMATION_DURATION = 1000; private static final int DEFAULT_ANIMATION_TOTAL_DURATION = DEFAULT_ANIMATION_DURATION * 5; private Paint mPaint; private float mRadius; private long[] mStartTicks; private boolean isRunning = false; public CircleAnimationDrawable(float mRadius) &#123; super(); this.mRadius = mRadius; mPaint = new Paint(); mPaint.setStyle(Paint.Style.FILL); mPaint.setAntiAlias(true); mPaint.setColor(0xffff00ff); &#125; @Override public void draw(@NonNull Canvas canvas) &#123; if (null == mStartTicks) &#123; return; &#125; for (int i = 0; i &lt; mStartTicks.length; i++) &#123; float curPercent = calculateCurPercent(mStartTicks[i]); float alpha = -(curPercent * curPercent) + 1; mPaint.setAlpha((int) (255 * alpha)); float radius = curPercent * mRadius; Rect bounds = getBounds(); float x = bounds.centerX(); float y = bounds.centerY(); canvas.drawCircle(x, y, radius, mPaint); &#125; &#125; private float calculateCurPercent(long startTicks) &#123; float curPercent = 0.0f; if (isRunning()) &#123; float loopMillis = DEFAULT_ANIMATION_TOTAL_DURATION; curPercent = (AnimationUtils.currentAnimationTimeMillis() - startTicks) / loopMillis; while (curPercent &gt; 1) &#123; curPercent--; startTicks += loopMillis; &#125; &#125; return curPercent; &#125; @Override public void setAlpha(int alpha) &#123; &#125; @Override public void setColorFilter(ColorFilter colorFilter) &#123; if (null != mPaint) &#123; mPaint.setColorFilter(colorFilter); &#125; &#125; public void setColorFilter(int color) &#123; if (null != mPaint) &#123; mPaint.setColor(color); &#125; &#125; @Override public int getOpacity() &#123; return PixelFormat.TRANSLUCENT; &#125; @Override public void start() &#123; if (!isRunning()) &#123; isRunning = true; long curTime = AnimationUtils.currentAnimationTimeMillis(); mStartTicks = new long[5]; for (int i = 0; i &lt; mStartTicks.length; i++) &#123; mStartTicks[i] = curTime + DEFAULT_ANIMATION_DURATION * i; &#125; run(); &#125; &#125; @Override public void stop() &#123; if (isRunning()) &#123; unscheduleSelf(this); isRunning = false; &#125; &#125; @Override public boolean isRunning() &#123; return isRunning; &#125; @Override public void run() &#123; invalidateSelf(); scheduleSelf(this, AnimationUtils.currentAnimationTimeMillis() + (1000 / 60)); &#125; @Override public int getIntrinsicWidth() &#123; return (int) (2 * mRadius); &#125; @Override public int getIntrinsicHeight() &#123; return (int) (2 * mRadius); &#125; @Override public int getMinimumWidth() &#123; return (int) (2 * mRadius); &#125; @Override public int getMinimumHeight() &#123; return (int) (2 * mRadius); &#125;&#125; 声明LICENSE]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 系统评分的调用及自定义]]></title>
    <url>%2F2016%2F08%2F15%2Fwt-android-intent-market%2F</url>
    <content type="text"><![CDATA[简介开发中遇到了设置自己应用某页面为系统商店页面。 调用仅调用系统应用商店/** * 调用系统应用商店 * * @return true: 调用成功 false: 调用失败 */public static boolean intent2AppMarket(Context context) &#123; try &#123; Intent startintent = new Intent("android.intent.action.MAIN"); startintent.addCategory("android.intent.category.APP_MARKET"); startintent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(startintent); return true; &#125; catch (Exception e) &#123; Log.e("AppMarketAct", "e:" + e); return false; &#125;&#125; 调用至系统应用商店对于详情页面/** * 调用系统应用商店 * * @return true: 调用成功 false: 调用失败 */public static boolean intent2AppMarketDetail(Context context) &#123; try &#123; Uri uri = Uri.parse("market://details?id=" + context.getPackageName()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); return true; &#125; catch (Exception e) &#123; Log.e("AppMarketAct", "e:" + e); return false; &#125;&#125; 声明为应用商店通过启动类Category声明(对应仅调用系统应用商店）在Manifest的启动Activity的intent-filter中添加&lt;category android:name=&quot;android.intent.category.APP_MARKET&quot; /&gt;即可 &lt;activity android:name=".BeginActivity" android:label="@string/app_name" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;category android:name="android.intent.category.APP_MARKET" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 通过声明Scheme跳转具体详情页(对于调用至系统应用商店对于详情页面)实现原理 对于Android平台而言，URI是由scheme,host,port,path,queryString组成，格式为scheme://host:port/path?qureyParameter=queryString 对于Android平台而言，market://details?id=pkName为默认的约定俗成的URI 实现步骤 在Manifest中为此中转类设置对应intent-filter并设置exported为true &lt;activity android:name=".appmarket.LinkProxyActivity" android:exported="true" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="market" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在中转类中获取对应的id进行跳转或其他处理 public class ProxyActivity extends Activity&#123; private static final String TAG = "ProxyActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = getIntent(); Log.i(TAG, "scheme: "+intent.getScheme()); Uri uri = intent.getData(); Log.i(TAG, "scheme: "+uri.getScheme()); Log.i(TAG, "host: "+uri.getHost()); Log.i(TAG, "path: "+uri.getPath()); Log.i(TAG, "query: "+uri.getQuery()); Log.i(TAG, "query id: "+uri.getQueryParameter("id")); //FIXME 跳转或其他相关操作，并关闭此中转页面 &#125;&#125; Log打印结果如下: I/ProxyActivity: scheme: marketI/ProxyActivity: scheme: marketI/ProxyActivity: host: detailsI/ProxyActivity: path: I/ProxyActivity: query: id=com.jianshu.harukiI/ProxyActivity: query id: com.jianshu.haruki]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 收藏方法]]></title>
    <url>%2F2016%2F08%2F08%2Fwt-android-methods%2F</url>
    <content type="text"><![CDATA[简介保存平时收集到的常用方法，以便以后调用。 目录 获取手机验证码 图片旋转 获取设备所有的存储路径 获取应用进程信息 获取已安装软件的大小 生成带倒影的Bitmap图像 ImageLoader加载本地图片工具类 获取手机验证码SmsObservermSObserver = new SmsObserver(mContext, new Handler()); mContext.getContentResolver().registerContentObserver(SMS_INBOX, true, mSObserver); private Uri SMS_INBOX = Uri.parse("content://sms/"); private class SmsObserver extends ContentObserver &#123; private Cursor cursor = null; public SmsObserver(Context context, Handler handler) &#123; super(handler); &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); getSmsFromPhone(); &#125; private void getSmsFromPhone() &#123; ContentResolver cr = mContext.getContentResolver(); String[] projection = new String[] &#123; "body" &#125;; // 10655198881 String where = " address = '10655198881' AND date &gt; " + (System.currentTimeMillis() - 1 * 60 * 1000); Cursor cur = cr.query(SMS_INBOX, projection, where, null, "date desc"); if (null == cur) return; if (cur.moveToNext()) &#123; String body = cur.getString(cur.getColumnIndex("body")); Pattern pattern = Pattern.compile("[0-9]&#123;6&#125;"); Matcher matcher = pattern.matcher(body); if (matcher.find()) &#123; String res = matcher.group().substring(1, 7); //设置code mCodeEdit.setText(res); return; &#125; &#125; &#125; &#125; 图片旋转public static Bitmap rotateBitmap(int degree, Bitmap bitmap) &#123; Matrix matrix = new Matrix(); matrix.postRotate(degree); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125; 获取设备所有的存储路径有2种方法，方法1为调用系统方法getVolumePaths获取，方法2为自己解析/proc/mounts文件下的路径 方法1public static String[] getVolumePaths(Context context) &#123; try &#123; StorageManager sm = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE); String[] paths = (String[]) StorageManager.class.getMethod("getVolumePaths").invoke(sm); List&lt;String&gt; ps = new ArrayList&lt;String&gt;(); for (String path : paths) &#123; String status = (String) StorageManager.class.getMethod("getVolumeState", String.class).invoke(sm, path); if (status.equals(android.os.Environment.MEDIA_MOUNTED)) &#123; ps.add(path); &#125; &#125; return ps.toArray(new String[ps.size()]); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 方法2public static String[] getExternalStoragePaths() &#123; BufferedReader in = null; try &#123; in = new BufferedReader(new InputStreamReader(new FileInputStream("/proc/mounts"))); List&lt;String&gt; ps = new ArrayList&lt;String&gt;(); try &#123; for (String l; (l = in.readLine()) != null; ) &#123; if (contains(l, KW_BLACK) || !contains(l, KW_WHITE)) &#123; continue; &#125; String[] elements = l.split(" "); if (elements.length &gt; 1 &amp;&amp; elements[1] != null) &#123; ps.add(elements[1]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return ps.toArray(new String[ps.size()]); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123;&#125; &#125; &#125; return null;&#125; private static boolean contains(String src, String[] kws) &#123; if (src != null &amp;&amp; kws != null) &#123; for (String kw : kws) &#123; if (src.contains(kw)) &#123; return true; &#125; &#125; &#125; return false;&#125; private static final String[] KW_BLACK = &#123; "secure", "asec", "legacy", "shell", "private", "obb", "media", "smb", "Bootloader", "Reserve", "on", &#125;; private static final String[] KW_WHITE = &#123; "fat", &#125;; 获取应用进程信息根据系统提供的方法ActivityManager.getRunningAppProcesses可以获取到，但是在API &gt;= 22的设备上获取的信息是不完整的，此时可以通过获取/proc下文件夹进行比对（在开启应用时，在此路径下都会加载一个文件夹用于保存进程信息）,方法来源于GitHub。 部分代码展示public static List&lt;AndroidAppProcess&gt; getRunningForegroundApps(Context ctx) &#123; List&lt;AndroidAppProcess&gt; processes = new ArrayList&lt;&gt;(); File[] files = new File("/proc").listFiles(); PackageManager pm = ctx.getPackageManager(); for (File file : files) &#123; if (file.isDirectory()) &#123; int pid; try &#123; pid = Integer.parseInt(file.getName()); &#125; catch (NumberFormatException e) &#123; continue; &#125; try &#123; AndroidAppProcess process = new AndroidAppProcess(pid); if (process.foreground // ignore system processes. First app user starts at 10000. &amp;&amp; (process.uid &lt; 1000 || process.uid &gt; 9999) // ignore processes that are not running in the default app process. &amp;&amp; !process.name.contains(":") // Ignore processes that the user cannot launch. &amp;&amp; pm.getLaunchIntentForPackage(process.getPackageName()) != null) &#123; processes.add(process); &#125; &#125; catch (AndroidAppProcess.NotAndroidAppProcessException ignored) &#123; &#125; catch (IOException e) &#123; log(e, "Error reading from /proc/%d.", pid); // System apps will not be readable on Android 5.0+ if SELinux is enforcing. // You will need root access or an elevated SELinux context to read all files under /proc. &#125; &#125; &#125; return processes;&#125; 获取已安装软件的大小public void queryPacakgeSize(AppInfo info) throws Exception &#123; if (info != null &amp;&amp; info.packageName != null) &#123; // 使用放射机制得到PackageManager类的隐藏函数getPackageSizeInfo try &#123; int sdkcode = getAndroidSDKVersion(); if (sdkcode &gt; 16) &#123; Method getPackageSizeInfo = mPackageManager.getClass() .getDeclaredMethod("getPackageSizeInfo", String.class, int.class, IPackageStatsObserver.class); // 调用该函数，并且给其分配参数 ，待调用流程完成后会回调PkgSizeObserver类的函数 getPackageSizeInfo.invoke(mPackageManager, info.packageName, android.os.Process.myUid() / 100000, new PkgSizeObserver(info)); &#125; else &#123; // 通过反射机制获得该隐藏函数 Method getPackageSizeInfo = mPackageManager.getClass() .getDeclaredMethod("getPackageSizeInfo", String.class, IPackageStatsObserver.class); // 调用该函数，并且给其分配参数 ，待调用流程完成后会回调PkgSizeObserver类的函数 getPackageSizeInfo.invoke(mPackageManager, info.packageName, new PkgSizeObserver(info)); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); throw ex; // 抛出异常 &#125; &#125; &#125; 生成带倒影的Bitmap图像public static Bitmap createReflectedImage(Bitmap originalImage, float reflectionHeightScale, int width, int height, int space) &#123; if (null == originalImage) &#123; throw new IllegalArgumentException("src can not be null"); &#125; if (reflectionHeightScale &lt;= 0 || reflectionHeightScale &gt; 1) &#123; throw new IllegalArgumentException( "reflectionHeightScale must be during 0 ~ 1"); &#125; int reflectionHeight = (int) (height * reflectionHeightScale); Matrix matrix = new Matrix(); // 实现图片翻转90度 matrix.preScale(1, -1); // 创建倒影图片 Bitmap reflectionImage = Bitmap.createBitmap(originalImage, 0, height - reflectionHeight, width, reflectionHeight, matrix, false); // 创建总图片（原图片 + 倒影图片） Bitmap finalReflection = Bitmap.createBitmap(width, (height + reflectionHeight) + space, Config.ARGB_8888); // 创建画布 Canvas canvas = new Canvas(finalReflection); canvas.drawBitmap(originalImage, 0, 0, null); // 把倒影图片画到画布上 canvas.drawBitmap(reflectionImage, 0, height + 1 + space, null); Paint shaderPaint = new Paint(); // 创建线性渐变LinearGradient对象 LinearGradient shader = new LinearGradient(0, originalImage.getHeight(), 0, finalReflection.getHeight() + 1, 0x70ffffff, 0x00ffffff, TileMode.MIRROR); shaderPaint.setShader(shader); shaderPaint.setXfermode(new PorterDuffXfermode(Mode.DST_IN)); // 画布画出反转图片大小区域，然后把渐变效果加到其中，就出现了图片的倒影效果。 canvas.drawRect(0, height + 1, width, finalReflection.getHeight(), shaderPaint); return finalReflection;&#125; ImageLoader加载本地图片工具类import android.widget.ImageView;import com.nostra13.universalimageloader.core.ImageLoader;/** * 异步加载本地图片工具类 * * @author tony * */public class LoadLocalImageUtil &#123; private LoadLocalImageUtil() &#123; &#125; private static LoadLocalImageUtil instance = null; public static synchronized LoadLocalImageUtil getInstance() &#123; if (instance == null) &#123; instance = new LoadLocalImageUtil(); &#125; return instance; &#125; /** * 从内存卡中异步加载本地图片 * * @param uri * @param imageView */ public void displayFromSDCard(String uri, ImageView imageView) &#123; // String imageUri = "file:///mnt/sdcard/image.png"; // from SD card ImageLoader.getInstance().displayImage("file://" + uri, imageView); &#125; /** * 从assets文件夹中异步加载图片 * * @param imageName * 图片名称，带后缀的，例如：1.png * @param imageView */ public void dispalyFromAssets(String imageName, ImageView imageView) &#123; // String imageUri = "assets://image.png"; // from assets ImageLoader.getInstance().displayImage("assets://" + imageName, imageView); &#125; /** * 从drawable中异步加载本地图片 * * @param imageId * @param imageView */ public void displayFromDrawable(int imageId, ImageView imageView) &#123; // String imageUri = "drawable://" + R.drawable.image; // from drawables // (only images, non-9patch) ImageLoader.getInstance().displayImage("drawable://" + imageId, imageView); &#125; /** * 从内容提提供者中抓取图片 */ public void displayFromContent(String uri, ImageView imageView) &#123; // String imageUri = "content://media/external/audio/albumart/13"; // // from content provider ImageLoader.getInstance().displayImage("content://" + uri, imageView); &#125;&#125;]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TextView头尾展示标签图片，并且尾部标签不被挤出]]></title>
    <url>%2F2016%2F08%2F03%2Fwt-center-image-span%2F</url>
    <content type="text"><![CDATA[简介开发中需要为TextView头尾添加标签图片，并且尾部标签不被挤出，考虑了几种可能的方案： 动态计算TextView的文本长度和每行的宽度 使用TextView的Span 自定义一个View，自己绘制文本和标签图片 对比 第一种由于Android的碎片化极其严重，各种机型，各种字体等等，更重要的是TextView并没有对应的API可以进行回去绘制。PASS。 第二种可行性还是不错的，Android原生支持了很多类型的Span。但是有一个问题就是没有可以当图片和文本居中的Span可以使用。如果使用就必须自定义一个Span。查看DynamicDrawableSpan,ImageSpan等Span的源码，发现自定义的话是可以满足的。待定。 第三种自己可以定制自己想实现的各种效果。但是适配性比较难保证。待定 最后综合考虑，实验第二种是否能满足，如果不能满足，则使用第三种。 方案二自定义Span涉及到的类：Paint.FontMetrics，它表示绘制字体时的度量标准。Google的官方api文档对它的字段说明如下： ascent: 字体最上端到基线的距离，为负值。 descent：字体最下端到基线的距离，为正值。 bottom: 最下字符到baseline的距离。即为descent的最大值 top: 最高字符到baseline的距离。即为ascent的最大值 leading: 上一行字符的descent到下一行字符ascent的距离 回到主题，我们要让图片与Textview对齐，只需把图片放到descent线和ascent线之间的中间位置就可以了。实现方式为仿照DynamicDrawableSpan，重写DynamicDrawableSpan类的draw方法。最终实现如下： /** * TagTitleViewSpan * &lt;p&gt; * 仿照&#123;@link android.text.style.DynamicDrawableSpan&#125; * &lt;p&gt; * Created by wt on 17/3/10. */class TagTitleViewSpan extends ReplacementSpan &#123; // ...省略构造参数 // 绘制实现类 private TagViewInner mTagInner; @Override public int getSize(@NonNull Paint paint, CharSequence text, @IntRange(from = 0) int start, @IntRange(from = 0) int end, @Nullable Paint.FontMetricsInt fm) &#123; if (null == mTagInner || !mTagInner.isValid()) &#123; return 0; &#125; Rect rect = mTagInner.getRect(); if (fm != null) &#123; // 保证当文字高度低于图片时，文字居中 Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top; int drHeight = rect.bottom - rect.top; int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fm.ascent = -bottom; fm.top = -bottom; fm.bottom = top; fm.descent = top; &#125; return rect.width() &lt; 0 ? 0 : rect.width(); &#125; @Override public void draw(@NonNull Canvas canvas, CharSequence text, @IntRange(from = 0) int start, @IntRange(from = 0) int end, float x, int top, int y, int bottom, @NonNull Paint paint) &#123; if (null == mTagInner || !mTagInner.isValid()) &#123; return; &#125; Rect rect = mTagInner.getRect(); int transY = 0; switch (mVerticalAlignment) &#123; case ALIGN_BASELINE: transY = bottom - rect.bottom - paint.getFontMetricsInt().descent; break; case ALIGN_TEXT_BOTTOM: Paint.FontMetricsInt fm1 = paint.getFontMetricsInt(); transY = y + fm1.descent / 2 - rect.bottom; break; case ALIGN_TEXT_CENTER: // 图片居中计算 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); transY = (y + fm.descent + y + fm.ascent) / 2 - rect.bottom / 2; if (transY &lt; 0) &#123; transY = 0; &#125; break; default: transY = bottom - rect.bottom; break; &#125; canvas.save(); // 绘制图片 canvas.translate(x, transY); mTagInner.draw(context, canvas); canvas.restore(); &#125;&#125; 文本长度问题既然图片插入和居中没有问题，那么最后一个问题就是如何保证尾部标签不被挤出呢。搜索到[Android]TextUtils.ellipsize()截取指定长度字符串(附图文混排)，让我注意到TextUtils.html.ellipsize(text, p, avail, where)这个方法。其中avail字段代表的是有效长度，text 代码需要截取的字段。这个方法是TextView截取的静态方法。经测试，可用。 avail字段必须是精确长度，意思就是说，他会按照你传入的长度对text截取。一开始，我是计算长度是按照： View的长度 * MaxLines - 图片已占用的长度 - padding(l,t,r,b) 当把截取后的文本设为TextView时，TextView会根据自身的属性进行布局，当文本文本换行时，如果遇到当前行空出部分字符的情况，就会导致实际的精确长度比我计算时的要短，最后的标签图片还是会截。无奈，经调试确认方案是：在计算时，每行减去textsize / 3，即： View的长度 * maxLines - 图片已占用的长度 - padding(l,t,r,b) - textsize / 3 * (maxLines - 1) 最后计算的代码如下： /** * 截取传入的字符串 * * @param old 传入的字符串 * @param usedWidth 已被占用的宽度 * @return 截取好的字符串 */private String measureText(String old, int usedWidth) &#123; if (TextUtils.isEmpty(old)) &#123; return null; &#125; int maxLines = TextViewCompat.getMaxLines(this); if (maxLines == Integer.MAX_VALUE) &#123; return old; &#125; if (maxLines &lt; 0) &#123; maxLines = 0; &#125; //有效文本展示区域 int availableWidth = maxLines * (getWidth() - getPaddingLeft() - getPaddingRight()) - usedWidth - (int) getTextSize() / 3 * (maxLines - 1); return (String) TextUtils.ellipsize(old, getPaint(), availableWidth, TextUtils.TruncateAt.END);&#125; 效果 方案三TODO 鸣谢 TextUtils.ellipsize()截取指定长度字符串(附图文混排) Android ImageSpan与TextView中的text居中对齐问题解决（无论TextView设置行距与否） Android字符串进阶之三：字体属性及测量（FontMetrics） Android ImageSpan的图文居中对齐]]></content>
      <categories>
        <category>Dev</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
